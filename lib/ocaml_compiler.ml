open Core.Std
open Async.Std
open Import

let tar_id = "dynlink.tgz"

let ocamlopt_opt = Ocaml_dynloader.ocamlopt_opt
let camlp4o_opt = Ocaml_dynloader.camlp4o_opt

let pervasives = "pervasives.cmi"
let config_file = "config.sexp"

let persistent_archive_subdir = "compiler"

let mandatory_embedded_files = [
  ocamlopt_opt;
  pervasives;
]

(* Map of the directories contents:
   - build_dir: /tmp/ocaml_plugin_XXXXX/{m_dyn_1_.ml,m_dyn_1_.o,m_dyn_1_.cmx,m_dyn_1_.cmxs,...}
     Deleted on clean up.
   - compiler_dir:
       Either /tmp/ocaml_plugin_XXXXX/{ocamlopt.opt,pervasives.cmi,pa_sexp_conv.cmo,...}
       or $user_specified_dir/compiler/{archive-info.sexp,the other files}.
       Locked if it is shared using $user_specified_dir/compiler.lock. Deleted on clean up
       if they are the same directory otherwise deleted when the digest of the archive
       doesn't match the info anymore.
   - cache dir:
       $user_specified_dir/cmxs-cache/{cache-info.sexp, abcd-efgh-ijkl-mnop.cmxs}
       copied there from build_dir
       Locked because it can be shared using $user_specified_dir/cmxs-cache.lock.
   Both locks are released on clean up. *)

module Archive_lock = struct
  type t =
  | Cleaned
  | Cleaning of unit Deferred.Or_error.t
  | Locked of string
end

type t = {
  loader : Ocaml_dynloader.t;
  archive_lock : Archive_lock.t ref;
} with fields

let clean t =
  Ocaml_dynloader.clean t.loader >>= fun r1 ->
  (match t.archive_lock.contents with
  | Archive_lock.Cleaned -> Deferred.Or_error.ok_unit
  | Archive_lock.Cleaning def -> def
  | Archive_lock.Locked lock_filename ->
    let clean =
      In_thread.run (fun () ->
        Or_error.try_with (fun () -> Core.Std.Lock_file.Nfs.unlock_exn lock_filename))
    in
    t.archive_lock.contents <- Archive_lock.Cleaning clean;
    clean >>| fun res ->
    t.archive_lock.contents <- Archive_lock.Cleaned;
    res)
  >>| fun r2 ->
  Or_error.combine_errors_unit [
    r1;
    r2;
  ]
;;

(* This external declaration should be implemented by the c files generated by
   by calling the omakeroot function OCamlPluginEmbeddedArchive.
   Calling this function takes 10 or 20ms => I won't bother avoiding the copying
   from C to caml. *)
external archive : unit -> string = "ocaml_plugin_archive"
let archive () =
  let str = archive () in
  if str = "dummy" then None else Some str
external archive_digest_binding : unit -> string = "ocaml_plugin_archive_digest"
let archive_digest () =
  Plugin_cache.Digest.of_string (archive_digest_binding ())

let () =
  match Core.Std.Sys.getenv "OCAML_PLUGIN_DUMP_ARCHIVE" with
  | None -> ()
  | Some _ ->
    (* This is a way of extracting the archive from the executable. It can be used like
       this: OCAML_PLUGIN_DUMP_ARCHIVE= ./run.exe | tar -xz
       We exit to avoid running any side effects that could be done later at toplevel. *)
    Printf.eprintf "archive digest: %s\n%!"
      (Plugin_cache.Digest.to_string (archive_digest ()));
    begin match archive () with
    | None -> Printf.printf "No archive\n%!"
    | Some str -> Printf.printf "%s%!" str;
    end;
    Core.Caml.Pervasives.exit 0

let save_archive_to destination =
  Deferred.Or_error.try_with (fun () ->
    match archive () with
    | None -> failwith "There is no embedded compiler in the current executable"
    | Some contents -> Writer.save destination ~contents
  )

exception Mandatory_file_not_found of string * string list with sexp

(* Because the directory is empty before check_mandatory_files is called (modulo the
   archive itself), it can return the contents of the archive simply by reading everything
   in the directory (assuming the archive doesn't contain directories). *)
let check_mandatory_files working_dir =
  let fct () =
    Sys.readdir working_dir
    >>| function content_of_working_dir ->
    let files = Array.to_list content_of_working_dir in
    let iter file =
      if not (List.mem ~equal:String.equal files file)
      then raise (Mandatory_file_not_found (file, files))
    in
    List.iter ~f:iter mandatory_embedded_files;
    files
  in
  Deferred.Or_error.try_with ~extract_exn:true fct

type 'a create_arguments = (
  ?persistent_archive_dirpath:string
  -> 'a
) Ocaml_dynloader.create_arguments

module Plugin_archive : sig
  val extract :
    archive_lock:Archive_lock.t ref
    -> persistent:bool
    -> string
    -> unit Deferred.Or_error.t
end = struct
  module Digest = Plugin_cache.Digest
  module Build_info = Plugin_cache.Build_info
  module Info = struct
    type t = {
      infos : (string * Sexp.t) list;
      build_info : Build_info.t;
      archive_digest : Digest.t;
    } with sexp

    let info_file_name = "archive-info.sexp"
    let info_file dir = dir ^/ info_file_name

    let create () =
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Unix.getlogin () >>| fun login ->
        [
          "version"  , sexp_of_string Params.version;
          "login"    , sexp_of_string login;
          "hostname" , sexp_of_string (Unix.gethostname ());
          "sys_argv" , <:sexp_of< string array >> Sys.argv;
        ]
      ) >>|? fun infos ->
      let archive_digest = archive_digest () in
      let build_info = Build_info.current in
      {
        infos;
        build_info;
        archive_digest;
      }

    let info_file_perm = 0o644

    let save dir =
      create () >>=? fun t ->
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Writer.save_sexp ~perm:info_file_perm (info_file dir) (sexp_of_t t)
      )

    let load dir =
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Reader.load_sexp_exn ~exclusive:true (info_file dir) t_of_sexp
      )

    let is_up_to_date t =
      Digest.compare (archive_digest ()) t.archive_digest = 0
  end

  exception Cannot_take_plugin_archive_lock of string with sexp

  let extract_throttle = Throttle.Sequencer.create ~continue_on_error:true ()

  let extract ~archive_lock ~persistent compiler_dir =
    let extract () =
      if_ persistent (fun () ->
        let lock_filename = compiler_dir ^ ".lock" in
        Shell.mkdir_p ~perm:0o755 (Filename.dirname lock_filename) >>=? fun () ->
        (In_thread.run (fun () ->
          try Core.Std.Lock_file.Nfs.create lock_filename with _ -> false
         ) >>= function
        | true ->
          archive_lock := Archive_lock.Locked lock_filename;
          Deferred.Or_error.ok_unit
        | false ->
          Deferred.Or_error.of_exn (Cannot_take_plugin_archive_lock lock_filename)
        ) >>=? fun () ->
        (* Beware of race condition in here. If we are killed in the middle of rm -rf, but
           the info file has not been deleted, then the extracted archive would be
           corrupted because it doesn't match the info file anymore.  This is why we first
           delete the info file, then delete everything else. *)
        Shell.rm ~r:() ~f:() [ Info.info_file compiler_dir ] >>=? fun () ->
        Shell.rm ~r:() ~f:() [ compiler_dir ] >>=? fun () ->
        Shell.mkdir_p ~perm:0o755 compiler_dir
      ) >>=? fun () ->
      let destination = compiler_dir ^/ tar_id in
      save_archive_to destination >>=? fun () ->
      Tar.extract ~working_dir:compiler_dir destination >>=? fun () ->
      if_ persistent (fun () -> Info.save compiler_dir)
    in
    if persistent
    then Throttle.enqueue extract_throttle (fun () ->
      Info.load compiler_dir >>= function
      | Ok info when Info.is_up_to_date info -> Deferred.Or_error.ok_unit
      | Ok _ | Error _ -> extract ()
    )
    else
      extract ()
end

let create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ?persistent_archive_dirpath
    () =
  let archive_lock = ref Archive_lock.Cleaned in
  (match persistent_archive_dirpath with
  | None     -> Deferred.return (Ok None)
  | Some path ->
    Shell.absolute_pathname path >>|? fun path ->
    Some (path ^/ persistent_archive_subdir)
  ) >>=? fun persistent_archive_dirpath ->
  let initialize_compilation_callback ~directory:build_dir =
    let persistent, compiler_dir =
      match persistent_archive_dirpath with
      | None                 -> false, build_dir
      | Some archive_dirpath -> true,  archive_dirpath
    in
    Plugin_archive.extract ~archive_lock ~persistent compiler_dir >>=? fun () ->
    check_mandatory_files compiler_dir >>=? fun files ->
    if List.mem files config_file
    then
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Reader.load_sexp_exn (compiler_dir ^/ config_file)
          Ocaml_dynloader.Config.t_of_sexp
        >>| Option.some
      )
    else Deferred.return (Ok None)
  in
  let in_compiler_dir exec =
    Option.value persistent_archive_dirpath ~default:"." ^/ exec
  in
  let include_directories =
    match persistent_archive_dirpath with
    | None -> include_directories
    | Some dir -> Some (dir :: Option.value include_directories ~default:[])
  in
  let ocamlopt_opt = in_compiler_dir ocamlopt_opt in
  let camlp4o_opt  = in_compiler_dir camlp4o_opt in
  let nostdlib flags = "-nostdlib" :: Option.value ~default:[] flags in
  let cmx_flags = nostdlib cmx_flags in
  let cmxs_flags = nostdlib cmxs_flags in
  Ocaml_dynloader.create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ~cmx_flags
    ~cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ~initialize_compilation_callback
    ~ocamlopt_opt
    ~camlp4o_opt
    () >>=? fun loader ->
  let compiler = {
    loader;
    archive_lock;
  } in
  Deferred.return (Ok (`this_needs_manual_cleaning_after compiler))

let created_but_not_cleaned = Bag.create ()
let () =
  (* I think we can rely on the at_shutdown handlers only firing in the current process
     and not in the forks. In that case, worse things could happen than deleting the
     compiler under our feet. *)
  Shutdown.at_shutdown (fun () ->
    Deferred.List.iter (Bag.to_list created_but_not_cleaned) ~f:(fun compiler ->
      clean compiler >>| function
      | Ok ()   -> ()
      | Error _ -> ()
    )
  )
let shutting_down () =
  match Shutdown.shutting_down () with
  | `No    -> false
  | `Yes _ -> true

exception Shutting_down with sexp

let with_compiler
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ?persistent_archive_dirpath
    ~f
    ()
    =
  if shutting_down () then Deferred.Or_error.of_exn Shutting_down else begin
    create
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?persistent_archive_dirpath
      ()
    >>=? function `this_needs_manual_cleaning_after compiler ->
    if shutting_down ()
    then
      clean compiler >>=? fun () ->
      Deferred.Or_error.of_exn Shutting_down
    else begin
      let bag_elem = Bag.add created_but_not_cleaned compiler in
      Deferred.Or_error.try_with_join ~extract_exn:true (fun () -> f compiler)
      >>= fun result ->
      Bag.remove created_but_not_cleaned bag_elem;
      clean compiler >>| fun r2 ->
      match result, r2 with
      | Ok result, Ok ()          -> Ok result
      | Ok _, (Error _ as error)  -> error
      | Error e1, Error e2        -> Error (Error.of_list [e1; e2])
      | Error _ as error, Ok ()   -> error
    end
  end

let make_load_ocaml_src_files load_ocaml_src_files =
  let aux
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?persistent_archive_dirpath
      files =
    let f compiler =
      let loader = loader compiler in
      load_ocaml_src_files loader files
    in
    with_compiler
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?persistent_archive_dirpath
      ~f
      ()
  in
  aux

module Make (X:Ocaml_dynloader.Module_type) = struct
  module M = Ocaml_dynloader.Make(X)
  let load_ocaml_src_files = make_load_ocaml_src_files M.load_ocaml_src_files
end

let load_ocaml_src_files = make_load_ocaml_src_files Ocaml_dynloader.load_ocaml_src_files
